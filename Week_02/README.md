学习笔记

### 树

对于树节点的操作，由于树节点之间的结构特性通常使用递归调用的方式去进行操作反而更加简单明了

树的遍历以根节点遍历顺序的不同分为：`前序`、`中序`、`后序`

**前序**

根节点先于左右子树节点遍历，即`root > 左子树 > 右子树`

对于前序遍历生成的数组，以任意一下标作为root，满足以下特性：

`[{...}, root, {左子树左边界下标, ..., 左子树右边界下标}, {右子树左边界下标, ..., 右子树右边界下标}, {...}]`

**中序**

根节点位于左右子树节点中间遍历，即`左子树 > root > 右子树`

对于中序遍历生成的数组，以任意一下标作为root，满足以下特性：

`[{...}, {左子树左边界下标, ..., 左子树右边界下标}, root, {右子树左边界下标, ..., 右子树右边界下标}, {...}]`

**后序**

根节点后于左右子树节点遍历，即`左子树 > 右子树 > root`

对于后序遍历生成的数组，以任意一下标作为root，满足以下特性：

`[{...}, {左子树左边界下标, ..., 左子树右边界下标}, {右子树左边界下标, ..., 右子树右边界下标}, root, {...}]`

#### 二叉树

即root节点下只包含两个节点，最常见的树

#### 二叉搜索树

在二叉树的基础上，添加了以下规则：

+ 父节点节点值大于左子树全部节点值
+ 父节点节点值小于右子树全部节点值

> 对于二叉搜索树的中序遍历生成的数组一定是有序的

### 堆

堆通常可以看作一个完全二叉树，常见的堆为：`大顶堆`、`小顶堆`

**大顶堆**

上层元素大于下层元素，堆顶为最大值

**小顶堆**

上层元素小于下层元素，堆顶为最小值

> 堆可用于排序、滑动窗口、前k个元素等应用问题（对于前k个元素利用快排思想更佳）

### 图

图分为`有向图`和`无向图`，同时还可以根据是否有权重属性再进行区分

对于图的遍历方式可分为`BFS`和`DFS`

> 树是一种无环图，因此通常情况BFS和DFS也同样适用于树

#### DFS

先进行深度遍历，再进行广度遍历。通常伴随着递归

通常代码模板

```java
void dfs(...) {
    if(终止条件){
        return;
    }
    // 状态调整
    dfs(...);
    // 回溯状态
}
```

#### BFS

先进行广度遍历，再进行深度遍历。

对于不进行层级操作的，代码模板

```java
void bfs(...) {
    Queue<?> queue = new LinkedList(); 
    queue.offer(start);
        
    while(!queue.isEmpty()) {
        Object o = queue.poll();
        // do something...
        for(循环条件) {
            queue.offer(...);
        }
    }
}
```

对于需要进行层级操作的，代码模板为

```java
void bfs(...) {
    Queue<?> queue = new LinkedList();
    queue.offer(start);

    while(!queue.isEmpty()) {
        // 开始之前记录当前层元素个数
        int size = queue.size();
        // 层级操作...
        for(int i = 0; i < size; i++) {
            Object o = queue.poll();
            // do something...
            for(循环条件) {
                queue.offer(...);
            }
        }
    }
}
```